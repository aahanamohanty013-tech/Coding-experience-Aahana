#include <Arduino.h>
#include "MAX30105.h"
#include <Wire.h>
#include <math.h>
#include "SensorPCF85063.hpp"
#include <lvgl.h>
#include "Arduino_GFX_Library.h"
#include "Arduino_DriveBus_Library.h"
#include "pin_config.h"
#include "lv_conf.h"
#include <demos/lv_demos.h>
#include "HWCDC.h"
#include "ui.h"
#include "heartRate.h"
#include <BLEDevice.h>
#include <BLEServer.h>
#include <BLEUtils.h>
#include <vector>
#include "Adafruit_LTR390.h"

Adafruit_LTR390 ltr = Adafruit_LTR390();
const float GAIN_FACTORS[] = {1.0, 3.0, 6.0, 9.0, 18.0};

const float RESOLUTION_INTEGRATION_FACTORS[] = {4.0, 2.0, 1.0, 0.5, 0.25, 0.03125};
const float RESOLUTION_BIT_FACTORS[] = {20.0, 19.0, 18.0, 17.0, 16.0, 13.0};
const float WINDOW_FACTOR = 1.0;

ltr390_gain_t currentGain = LTR390_GAIN_3;
ltr390_resolution_t currentResolution = LTR390_RESOLUTION_16BIT;

float getUVI() {
  ltr.setMode(LTR390_MODE_UVS);

  delay(200);

  uint32_t rawUVS = ltr.readUVS();
  if (rawUVS == 0) {
    return 0.0;
  }

  float gain_factor = GAIN_FACTORS[static_cast<int>(currentGain)];
  float resolution_bit_factor = RESOLUTION_BIT_FACTORS[static_cast<int>(currentResolution)];

  float uvi_divisor = (gain_factor / 18.0) *
                      (pow(2.0, resolution_bit_factor)) /
                      (pow(2.0, 20.0)) * 2300.0;

  if (uvi_divisor == 0) return 0.0;

  return (rawUVS / uvi_divisor) * WINDOW_FACTOR;
}

float getLux() {
  ltr.setMode(LTR390_MODE_ALS);

  delay(200);

  uint32_t rawALS = ltr.readALS();

  if (rawALS == 0) {
    return 0.0;
  }

  float gain_factor = GAIN_FACTORS[static_cast<int>(currentGain)];
  float resolution_integration_factor = RESOLUTION_INTEGRATION_FACTORS[static_cast<int>(currentResolution)];


  float lux_divisor = gain_factor * resolution_integration_factor;

  if (lux_divisor == 0) return 0.0;

  return (rawALS * 0.6) / lux_divisor * WINDOW_FACTOR;
}

HWCDC USBSerial;
const int voltageDividerPin = 1;
float vRef = 3.3;
float R1 = 200000.0;
float R2 = 100000.0;

// --- BLE Declarations ---
BLEServer* pServer = NULL;
BLECharacteristic* pHeartRateCharacteristic = NULL;
BLECharacteristic* pTEMPCharacteristic = NULL;
BLECharacteristic* pUVICharacteristic = NULL;
BLECharacteristic* pBatteryCharacteristic = NULL;
bool deviceConnected = false;

#define SERVICE_UUID                  "4fafc201-1fb5-459e-8fcc-c5c9c331914b"
#define HEARTRATE_CHARACTERISTIC_UUID "beb5483e-36e1-4688-b7f5-ea07361b26a8"
#define TEMP_CHARACTERISTIC_UUID      "86551cd5-ab1b-4b28-b51f-daf8e66d81c4"
#define UVI_CHARACTERISTIC_UUID       "a8b3d8d2-7e44-41a8-8617-7e81e3a4a45c"
#define BATTERY_CHARACTERISTIC_UUID   "5d05cd74-d7e0-4b18-9c14-e7f27df31d2e"
bool oldDeviceConnected = false;

class MyServerCallbacks : public BLEServerCallbacks {
    void onConnect(BLEServer* pServer) { deviceConnected = true; }
    void onDisconnect(BLEServer* pServer) { deviceConnected = false; }
};

// --- Sensor & Global State Declarations ---
MAX30105 particleSensor;
long randomNumber;
SensorPCF85063 rtc;
uint32_t lastMillis;

// --- Heart Rate Global Variables ---
const byte RATE_SIZE = 4;
byte rates[RATE_SIZE];
byte rateSpot = 0;
long lastBeat = 0;
volatile float beatsPerMinute;
volatile int beatAvg;

// --- FreeRTOS & Measurement State Variables ---
SemaphoreHandle_t bpmMutex;


// --- Button Debouncing Variables ---
bool buttonState = false;
bool lastButtonState = false;
unsigned long lastDebounceTime = 0;
unsigned long debounceDelay = 50;
bool clickDetected = false;


unsigned long lastTime = 0;
const int notifyInterval = 1000;

// --- Pin Definitions ---
#define IIC_SDA 11
#define IIC_SCL 10
#define vibOutpin 3
const int inputPin = 40;
const int outputPin = 41;
const int beePin = 42;

// --- Display & LVGL Declarations ---
Arduino_DataBus *bus = new Arduino_ESP32SPI(LCD_DC, LCD_CS, LCD_SCK, LCD_MOSI);
Arduino_GFX *gfx = new Arduino_ST7789(bus, LCD_RST, 0, true, LCD_WIDTH, LCD_HEIGHT, 0, 20, 0, 0);
std::shared_ptr<Arduino_IIC_DriveBus> IIC_Bus = std::make_shared<Arduino_HWIIC>(IIC_SDA, IIC_SCL, &Wire);
void Arduino_IIC_Touch_Interrupt(void);
std::unique_ptr<Arduino_IIC> CST816T(new Arduino_CST816x(IIC_Bus, CST816T_DEVICE_ADDRESS, TP_RST, TP_INT, Arduino_IIC_Touch_Interrupt));
#define EXAMPLE_LVGL_TICK_PERIOD_MS 2
uint32_t screenWidth;
uint32_t screenHeight;
static lv_disp_draw_buf_t draw_buf;


// --- LVGL Helper Functions ---
void Arduino_IIC_Touch_Interrupt(void) { CST816T->IIC_Interrupt_Flag = true; }

#if LV_USE_LOG != 0
void my_print(const char *buf) { USBSerial.printf(buf); USBSerial.flush(); }
#endif

void my_disp_flush(lv_disp_drv_t *disp, const lv_area_t *area, lv_color_t *color_p) {
    uint32_t w = (area->x2 - area->x1 + 1);
    uint32_t h = (area->y2 - area->y1 + 1);
#if (LV_COLOR_16_SWAP != 0)
    gfx->draw16bitBeRGBBitmap(area->x1, area->y1, (uint16_t *)&color_p->full, w, h);
#else
    gfx->draw16bitRGBBitmap(area->x1, area->y1, (uint16_t *)&color_p->full, w, h);
#endif
    lv_disp_flush_ready(disp);
}

void example_increase_lvgl_tick(void *arg) { lv_tick_inc(EXAMPLE_LVGL_TICK_PERIOD_MS); }

void my_touchpad_read(lv_indev_drv_t *indev_driver, lv_indev_data_t *data) {
    int32_t touchX = CST816T->IIC_Read_Device_Value(CST816T->Arduino_IIC_Touch::Value_Information::TOUCH_COORDINATE_X);
    int32_t touchY = CST816T->IIC_Read_Device_Value(CST816T->Arduino_IIC_Touch::Value_Information::TOUCH_COORDINATE_Y);
    if (touchX == -1 || touchY == -1) {
        data->state = LV_INDEV_STATE_REL;
        return;
    }
    if (CST816T->IIC_Interrupt_Flag == true) {
        CST816T->IIC_Interrupt_Flag = false;
        data->state = LV_INDEV_STATE_PR;
        if (touchX >= 0 && touchY >= 0) {
            data->point.x = touchX;
            data->point.y = touchY;
        }
    } else {
        data->state = LV_INDEV_STATE_REL;
    }
}

// --- FreeRTOS Task for Heart Rate Measurement ---
void heartRateTask(void *pvParameters) {
  USBSerial.println("Heart Rate Task started on Core 0");
  for (;;) {
    long irValue = particleSensor.getIR();
    if (checkForBeat(irValue) == true) {
      long delta = millis() - lastBeat;
      lastBeat = millis();
      float newBPM = 60 / (delta / 1000.0);
      if (newBPM < 255 && newBPM > 20) {
        rates[rateSpot++] = (byte)newBPM;
        rateSpot %= RATE_SIZE;
        int newBeatAvg = 0;
        for (byte x = 0; x < RATE_SIZE; x++)
          newBeatAvg += rates[x];
        newBeatAvg /= RATE_SIZE;
        if (xSemaphoreTake(bpmMutex, portMAX_DELAY) == pdTRUE) {
          beatsPerMinute = newBPM;
          beatAvg = newBeatAvg;
          xSemaphoreGive(bpmMutex);
        }
      }
    }
    vTaskDelay(pdMS_TO_TICKS(10));
  }
}

void getValues(lv_timer_t *timer);

// --- Main Setup Function ---
void setup() {
  USBSerial.begin(115200);
  pinMode(voltageDividerPin, INPUT);
  pinMode(inputPin, INPUT);
  pinMode(outputPin, OUTPUT);
  pinMode(beePin, OUTPUT);
  digitalWrite(outputPin, HIGH);
  pinMode(vibOutpin, OUTPUT);
  Wire.begin(IIC_SDA, IIC_SCL);

  randomNumber = random(55, 64);

  BLEDevice::init("ESP32");
  pServer = BLEDevice::createServer();
  pServer->setCallbacks(new MyServerCallbacks());
  BLEService *pService = pServer->createService(SERVICE_UUID);
  pHeartRateCharacteristic = pService->createCharacteristic(HEARTRATE_CHARACTERISTIC_UUID, BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY);
  pTEMPCharacteristic = pService->createCharacteristic(TEMP_CHARACTERISTIC_UUID, BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY);
  pUVICharacteristic = pService->createCharacteristic(UVI_CHARACTERISTIC_UUID, BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY);
  pBatteryCharacteristic = pService->createCharacteristic(BATTERY_CHARACTERISTIC_UUID, BLECharacteristic::PROPERTY_READ | BLECharacteristic::PROPERTY_NOTIFY);
  pService->start();
  pServer->getAdvertising()->addServiceUUID(SERVICE_UUID);
  pServer->getAdvertising()->start();
  USBSerial.println("BLE Initialized. Waiting for connection...");

  while (CST816T->begin() == false) {
    USBSerial.println("CST816T initialization fail");
    delay(2000);
  }
  USBSerial.println("CST816T initialization success");
  CST816T->IIC_Write_Device_State(CST816T->Arduino_IIC_Touch::Device::TOUCH_DEVICE_INTERRUPT_MODE, CST816T->Arduino_IIC_Touch::Device_Mode::TOUCH_DEVICE_INTERRUPT_PERIODIC);
  
  gfx->begin();
  pinMode(LCD_BL, OUTPUT);
  digitalWrite(LCD_BL, HIGH);
  screenWidth = gfx->width();
  screenHeight = gfx->height();
  
  lv_init();
  lv_color_t *buf1 = (lv_color_t *)heap_caps_malloc(screenWidth * screenHeight / 4 * sizeof(lv_color_t), MALLOC_CAP_DMA);
  lv_color_t *buf2 = (lv_color_t *)heap_caps_malloc(screenWidth * screenHeight / 4 * sizeof(lv_color_t), MALLOC_CAP_DMA);
  #if LV_USE_LOG != 0
  lv_log_register_print_cb(my_print);
  #endif
  lv_disp_draw_buf_init(&draw_buf, buf1, buf2, screenWidth * screenHeight / 4);
  static lv_disp_drv_t disp_drv;
  lv_disp_drv_init(&disp_drv);
  disp_drv.hor_res = screenWidth;
  disp_drv.ver_res = screenHeight;
  disp_drv.flush_cb = my_disp_flush;
  disp_drv.draw_buf = &draw_buf;
  lv_disp_drv_register(&disp_drv);
  static lv_indev_drv_t indev_drv;
  lv_indev_drv_init(&indev_drv);
  indev_drv.type = LV_INDEV_TYPE_POINTER;
  indev_drv.read_cb = my_touchpad_read;
  lv_indev_drv_register(&indev_drv);
  
  const esp_timer_create_args_t lvgl_tick_timer_args = {.callback = &example_increase_lvgl_tick, .name = "lvgl_tick"};
  esp_timer_handle_t lvgl_tick_timer = NULL;
  esp_timer_create(&lvgl_tick_timer_args, &lvgl_tick_timer);
  esp_timer_start_periodic(lvgl_tick_timer, EXAMPLE_LVGL_TICK_PERIOD_MS * 1000);
  
  ui_init();
  lv_timer_create(getValues, 1000, NULL);

    
  if (!particleSensor.begin(Wire, I2C_SPEED_STANDARD)) {
    USBSerial.println("MAX30105 was not found!");
  } else {
    USBSerial.println("MAX30105 Initialized.");
    particleSensor.setup();
    particleSensor.setPulseAmplitudeRed(0x7F);
    particleSensor.setPulseAmplitudeGreen(0);
  }
  
  // Set the RTC to the current time
  uint16_t year = 2025, month = 9, day = 26, hour = 15, minute = 40, second = 44;
  rtc.setDateTime(year, month, day, hour, minute, second);

  bpmMutex = xSemaphoreCreateMutex();
  if (bpmMutex == NULL) {
    USBSerial.println("Error creating bpmMutex");
  }

  xTaskCreatePinnedToCore(heartRateTask, "HeartRateTask", 4096, NULL, 1, NULL, 0);


  
  if ( ! ltr.begin() ) {
    // If the sensor is not found, halt the program
    USBSerial.println("LTR390 not found ... check your connections");
  }



  ltr.setGain(currentGain);
  ltr.setResolution(currentResolution);

}

// --- Main Loop (Arduino Task on Core 1) ---
void loop() {
  lv_timer_handler();
  delay(5);

  int reading = digitalRead(inputPin);
  if (reading != lastButtonState) { lastDebounceTime = millis(); }
  if ((millis() - lastDebounceTime) > debounceDelay) {
    if (reading != buttonState) {
      buttonState = reading;
      if (buttonState == LOW) {
        unsigned long pressStart = millis();
        while (digitalRead(inputPin) == LOW) {
          if (millis() - pressStart > 1000) {
            while (digitalRead(inputPin) == LOW) { delay(10); }
            clickDetected = false;
            lastButtonState = reading;
            return;
          }
          delay(10);
        }
        printf("Single Click\n");
        digitalWrite(outputPin, LOW);
        clickDetected = true;
        delay(100);
      } else {
        clickDetected = false;
      }
    }
  }
  lastButtonState = reading;
  
  int adcValue = analogRead(voltageDividerPin);
  float voltage = (float)adcValue * (vRef / 4095.0);
  float actualVoltage = voltage * ((R1 + R2) / R2);
  int batteryPercentage = (int)((actualVoltage / 4) * 100);

  if (deviceConnected && !oldDeviceConnected) {
    oldDeviceConnected = deviceConnected;
    USBSerial.println("Device connected");
  }
  if (!deviceConnected && oldDeviceConnected) {
    delay(500);
    BLEDevice::startAdvertising();
    oldDeviceConnected = deviceConnected;
    USBSerial.println("Device disconnected, restarting advertising");
  }

    if (deviceConnected && (millis() - lastTime > notifyInterval)) {
      int currentBeatAvg = 0;
      long irValue = particleSensor.getIR();
      
      if (xSemaphoreTake(bpmMutex, (TickType_t)10) == pdTRUE) {
        currentBeatAvg = beatAvg;
        xSemaphoreGive(bpmMutex);
      }

      if (irValue < 50000) {
        pHeartRateCharacteristic->setValue("0");
        pHeartRateCharacteristic->notify();
      } else {
         pHeartRateCharacteristic->setValue(String(currentBeatAvg).c_str());
         pHeartRateCharacteristic->notify();
        }
        float uvv = getUVI();
        float temp = particleSensor.readTemperature();
        String uviString = String(uvv, 2);
        pUVICharacteristic->setValue(uviString.c_str());
        pUVICharacteristic->notify();
        String tempString = String(temp, 2);
        pTEMPCharacteristic->setValue(tempString.c_str());
        pTEMPCharacteristic->notify();
        String batteryString = String(batteryPercentage);
        pBatteryCharacteristic->setValue(batteryString.c_str());
        pBatteryCharacteristic->notify();
        lastTime = millis();

    }
}

// --- LVGL Timer for UI Updates ---
void getValues(lv_timer_t *timer) {
  lv_obj_t *current_screen = lv_disp_get_scr_act(NULL);
  if (current_screen == ui_Screen2) {
    float lux = getLux();
    float uvi = getUVI();

    lv_label_set_text(ui_uviv, String(uvi, 2).c_str());
    lv_arc_set_value(ui_UVarc, uvi); // Update the arc value





    

  }
  else if (current_screen == ui_Screen3) {
    if (millis() - lastMillis > 1000) {
      lastMillis = millis();
      RTC_DateTime datetime = rtc.getDateTime();
      lv_label_set_text(ui_secsui, String(datetime.second).c_str());
      lv_label_set_text(ui_minsui, String(datetime.minute).c_str());
      lv_label_set_text(ui_hoursui, String(datetime.hour).c_str());
      lv_label_set_text(ui_dateui, (String(datetime.year) + "-" + String(datetime.month) + "-" + String(datetime.day)).c_str());
    }
  } else if (current_screen == ui_Screen4) {
    lv_label_set_text(ui_aqiv, String(randomNumber).c_str());
    lv_arc_set_value(ui_AQIarc, randomNumber);
  } 
  else if(current_screen == ui_Screen10) {
      float temp = particleSensor.readTemperature();
      lv_label_set_text(ui_tempv, String(temp).c_str());
      lv_arc_set_value(ui_tempv, temp);
    }

  else if (current_screen == ui_Screen11) {
    

      int currentBeatAvg = 0;
      long irValue = particleSensor.getIR();
      
      if (xSemaphoreTake(bpmMutex, (TickType_t)10) == pdTRUE) {
        currentBeatAvg = beatAvg;
        xSemaphoreGive(bpmMutex);
      }

      if (irValue < 50000) {
        lv_label_set_text(ui_hrv, "No finger?");
      } else {

             lv_label_set_text(ui_hrv, String(currentBeatAvg).c_str());
        }
    
    }
   else if (current_screen == ui_Screen5) {
    welcome_Animation(ui_welcome, 0);
    
  }
}
